# _Enumerations_

Recordemos el ejemplo anterior de la carrera:

```dart
void main() {
    const pos = 1;
    switch (pos) {
        case 1:
            print('Gold! ğŸ¤©');
            break;
        case 2:
            print('Silver! ğŸ˜');       
            break;
        case 3:
            print('Bronze! ğŸ˜Š');
            break;
        default:
            print('No medal! Try again! ğŸ’ª');
            break;
    }
}
```

En este caso, sabemos la cantidad de medallas que tenemos a disposiciÃ³n, por lo que el total de casos es limitado. QuÃ© bueno serÃ­a tener alguna __herramienta que nos permita crear un tipo que enumere posibilidades cuando__ estas __son limitadas y pocas__! ğŸ˜

AsÃ­ es! Eso son las _enumerations_! Las creamos de la siguiente manera:

1. Declaramos con `enum`
2. Luego el nombre del _type_ con la primer letra en _uppercase_.
3. Abrimos llaves,
4. Y dentro listamos los valores.

AsÃ­: `enum Medal { gold, silver, bronze, noMedal }`

Pero cÃ³mo las utilizamos? En conjunto con los `switch` _statements_, son una herramienta super poderosa. Primero creamos el tipo `Medal` fuera de nuestro `main` con los valores posibles, luego declaramos e inicializamos una variable de ese tipo `Medal` con el valor que queramos y luego la utilizamos como variable que vamos a observar. Como los casos son limitados segÃºn ese tipo (4, segÃºn cada medalla), entonces no nos hace falta un `default` ya que jamÃ¡s caerÃ­amos allÃ­:

```dart
enum Medal { gold, silver, bronze, noMedal }

void main() {
    final medal = Medal.gold;
    switch (medal) {
        case Medal.gold:
            print('Gold! ğŸ¤©');
            break;
        case Medal.silver:
            print('Silver! ğŸ˜');       
            break;
        case Medal.bronze:
            print('Bronze! ğŸ˜Š');
            break;
        case Medal.noMedal:
            print('No medal! Try again! ğŸ’ª');
            break;
    }
}
```

AsÃ­, definimos un tipo `Medal` que __tiene mucho significado y todo nuestro cÃ³digo se vuelve mÃ¡s fÃ¡cil de entender__. AdemÃ¡s, podemos __utilizar las ayudas__ que nos provee Dartpad en este caso:

![Ayuda en enums](4.7.1_ayuda_enums.png)

## ğŸ’ª Lluvia de enums

__Requirement__: piensen y escriban 5 enums que se les ocurran podrÃ­an cumplir con las consignas anteriores. No hace falta escriban ningÃºn `switch`; solamente los `enum`.

__Extra help__: les dejo otro ejemplo: dÃ­as de la semana.

---

__ğŸ’€ SoluciÃ³n__:

```dart
enum Suits { hearts, diamons, clubs, spades}
enum Weather { sunny, cloudy, rainy, snowy }
enum OperatingSystems { windows, linux, mac }
enum MeansOfTransport { car, bycicle, motorcycle, plane, boat}
enum MostUsedLanguages { english, spanish, chinese}
```

## _Trailing comma_

Simple! ğŸ’€ Quiero prueben escribir estos dos _enum_ exactamente como se los dejo (prestando atenciÃ³n a las comas), clickeen donde dice 'Format' en Dartpad y vean quÃ© sucede:

`enum Weather { sunny, cloudy, rainy, snowy }`
`enum Weather { sunny, cloudy, rainy, snowy, }`

No es necesaria esa coma luego del Ãºltimo valor del `enum` pero es __muy recomendable__ ya que cuando Dartpad (y luego nuestro editor de cÃ³digo) dÃ© formato a nuestro cÃ³digo, va a __alinear en forma de columna__ en lugar de fila y lo hace mucho mÃ¡s legible en la mayorÃ­a de los casos. Y esto no aplica solo a los `enum` sino a __cualquier lista de valores separados por una coma!__

## Un poquito mÃ¡s sobre `enum`

FÃ­jense quÃ© sucede si intentan imprimir un valor de un `enum`:

```dart
enum Medal { gold, silver, bronze, noMedal }

void main() {
    final medal = Medal.gold;
    print(medal); // Medal.gold
    switch (medal) {
        case Medal.gold:
            print('Gold! ğŸ¤©');
            break;
        case Medal.silver:
            print('Silver! ğŸ˜');       
            break;
        case Medal.bronze:
            print('Bronze! ğŸ˜Š');
            break;
        case Medal.noMedal:
            print('No medal! Try again! ğŸ’ª');
            break;
    }
}
```

Y ustedes esperaban que se imprima el nombre! Bueno, para eso (ğŸ’€), simplemente agreguen un punto al terminar la variable `medal` para llamar a sus mÃ©todos y vean quÃ© pasa!

Pueden utilizar el `medal.name` para imprimir el nombre que le asignaron a la variable en lugar de que les imprima por ejemplo, `Medal.gold`.

AdemÃ¡s de esto, podrÃ­amos ver todos los valores de nuestro `enum` llamÃ¡ndolos de esta manera: `Medal.values` y hasta llamar a uno particularmente, asÃ­: `Medal.values.byName('silver'`).
