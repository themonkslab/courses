# Sets

Son collecciones al igual que las listas con las diferencias que las √∫ltimas, pueden contener valores repetidos mientras que los _set_ no. __Los `Set` son colecciones de valores √∫nicos__ y declaramos sus versiones _literal_ con _curly-braces_ o `{ }`:

```dart
void main() {
    var cities = ['Cordoba', 'New York', 'Paris'];
    var countries = {'Italy', 'UK', 'Russia'};
    print(cities);
    print(countries);
}
```

Si quisi√©ramos acceder a un elemento dentro del `Set`, no podemos utilizar el _subscript operator_ o `[index]`. En ellos, debemos utilizar el m√©todo `elementAt':

```dart
void main() {
    var countries = {'Italy', 'UK', 'Russia'};
    print(countries.elementAt(1)); // UK
}
```

## _Add and remove_

Podemos agregar elementos a nuestro `Set`. Al igual que las `List`, si agregamos un elemento mediante `add`, dicho elemento se agregar√° al final:

```dart
void main() {
    var countries = {'Italy', 'UK', 'Russia'};
    countries.add('Iceland');
    print(countries);
}
```

üíÄ Qu√© sucede sin embargo si intentamos hacer lo siguiente? Cu√°l ser√° el resultado de ese `print`?

```dart
void main() {
    var countries = {'Italy', 'UK', 'Russia'};
    countries.add('Italy');
    print(countries);
}
```

Exacto! Ya que los `Set` dijimos contienen valores √∫nicos, si agregamos un valor que ya se encuentra all√≠, entonces no hace nada!

Podemos tambi√©n eliminar elementos utilizando `remove` y si intentamos eliminar un elemento que no se encuentra en el `Set`, este se mantiene sin producir errores:

```dart
void main() {
    var countries = {'Italy', 'UK', 'Russia'};
    countries.remove('India');
    print(countries);
}
```

## _Last, first, length, and contains_

Funcionan de la misma manera que en las `List` por lo que no ahondaremos en ellos.

## _Union, intersection and difference_

Estos s√≠ son m√©todos particulares de los `Set` y pueden sernos de mucha utilidad.

El m√©todo __`union` nos permite unir `Set`, manteniendo los elementos √∫nicos__ aun si hay repeticiones:

```dart
void main() {
    var europeanCountries = {'Italy', 'UK', 'Russia'};
    var asianCountries = {'India', 'China', 'Russia'};
    print(europeanCountries.union(asianCountries)); // {Italy, UK, Russia, India, China}
}
```

El m√©todo __`intersection` nos permite encontrar qu√© elementos son comunes__ entre ambos `Set`:

```dart
void main() {
    var europeanCountries = {'Italy', 'UK', 'Russia'};
    var asianCountries = {'India', 'China', 'Russia'};
    print(europeanCountries.intersection(asianCountries)); // {Russia}
}
```

El m√©todo __`difference` nos permite encontrar qu√© elementos est√°n en el primer `Set` pero no en el segundo__:

```dart
void main() {
    var europeanCountries = {'Italy', 'UK', 'Russia'};
    var asianCountries = {'India', 'China', 'Russia'};
    print(europeanCountries.difference(asianCountries)); // {'Italy', 'UK'}
}
```

Finalmente, tambi√©n pueden utilizar _loops_ con ellos:

```dart
void main() {
    var europeanCountries = {'Italy', 'UK', 'Russia'};
    for(var country in europeanCountries) {
        print(country);
    }
}
```

## üí™

__Requirement__: dados dos _sets_ de `int` llamados `a` y `b`, escribir un programa que calcule y retorne otro `Set` con los elementos del primero y del segundo pero que no son comunes a ambos. Luego calcular la suma de los elementos del `Set` resultante.

```dart
void main() {
    const a = { 1, 3 };
    const b = { 3, 5 };
    // Deber√≠a imprimir { 1, 5 } y luego 6
}
```

---

__üíÄ Soluci√≥n__:

```dart
void main() {
    const a = { 1, 3 };
    const b = { 3, 5 };
    
    var resultantSet = <int>{};
    resultantSet = a.difference(b).union(b.difference(a));
    print('Resultant set: $resultantSet');

    var sumOfElements = 0;
    for(var value in resultantSet) {
        sumOfElements += value;
    }
    print('Sum of elements: $sumOfElements');
}
```

__üßê Importante__:

- Noten c√≥mo declaramos un `Set` _literal_: `<int>{}`. Si lo hacemos solamente con `{}` Dart va a creer que estamos declarando un `Map`, _type_ que veremos exactamente a continuaci√≥n.
